import pefile
import os
import array
import math
import pickle
from sklearn.externals import joblib
import sys
import argparse
from tkinter import *
from tkinter.filedialog import askopenfile
from tkinter.filedialog import askopenfilename
import pandas as pd
import numpy as np
from IPython.display import display
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC

############ Fonctions ############

#Obetenir l'entropie d'un executable
def get_entropy(data):
    if len(data) == 0:
        return 0.0
    occurences = array.array('L', [0]*256)
    for x in data:
        occurences[x if isinstance(x, int) else ord(x)] += 1

    entropy = 0
    for x in occurences:
        if x:
            p_x = float(x) / len(data)
            entropy -= p_x*math.log(p_x, 2)

    return entropy

#Obtenir les informations d'un executable
def get_resources(pe):
    """Extract resources :
    [entropy, size]"""
    resources = []
    if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
        try:
            for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                if hasattr(resource_type, 'directory'):
                    for resource_id in resource_type.directory.entries:
                        if hasattr(resource_id, 'directory'):
                            for resource_lang in resource_id.directory.entries:
                                data = pe.get_data(resource_lang.data.struct.OffsetToData, resource_lang.data.struct.Size)
                                size = resource_lang.data.struct.Size
                                entropy = get_entropy(data)

                                resources.append([entropy, size])
        except Exception as e:
            return resources
    return resources

#Ouverture d'un fichier
def open_file():
    file = askopenfilename() 
    if file is not None:
        data = {}
        #Récupération des données du fichier
        pe = pefile.PE(file)
        data['Subsystem'] = pe.OPTIONAL_HEADER.Subsystem
        data['MajorSubsystemVersion'] = pe.OPTIONAL_HEADER.MajorSubsystemVersion
        data['SizeOfOptionalHeader'] = pe.FILE_HEADER.SizeOfOptionalHeader
        data['DllCharacteristics'] = pe.OPTIONAL_HEADER.DllCharacteristics

        
        resources= get_resources(pe)
        if len(resources)> 0:
            entropy = list(map(lambda x:x[0], resources))
            data['ResourcesMinEntropy'] = min(entropy)
            data['ResourcesMaxEntropy'] = max(entropy)
        else:
            data['ResourcesMinEntropy'] = 0
            data['ResourcesMaxEntropy'] = 0
            

    entropy = list(map(lambda x:x.get_entropy(), pe.sections))    
    data['SectionsMeanEntropy'] = sum(entropy)/float(len(entropy))
    data['SectionsMaxEntropy'] = max(entropy)

    fileData = data
    #Transformation en dataframe
    fileData = pd.DataFrame([fileData])

    #Scaling des valeur du fichier
    for col in fileData.columns:
    	fileData[col] = (fileData[col] - malware_scaling[col].median()) / (malware_scaling[col].max() - malware_scaling[col].min())

   
    #Prédiction
    y_eval = poly_kernel_svm_clf.predict(fileData)
    
    #Interprétation du résultat
    if y_eval[0] == 1:
        exeType = "L'exécutable n'est pas un virus"
    elif y_eval[0] == 0:
        exeType = "L'exécutable est un virus"
    else:
        exeType = "L'exécutable n'est pas reconnus"

    lbl=Label(window, text=exeType, fg='red', font=("Helvetica", 12))
    lbl.place(x=110, y=110)
    print("\n Résultat: ")
    print(y_eval)


############ Fin fonction ############

# Chargement du dataset
malware = pd.read_csv('https://raw.githubusercontent.com/securitylab-repository/malware_classification/master/datasets/malware-detection/malwaredata.csv', delimiter=',')

malware_scaling = malware[["Subsystem","MajorSubsystemVersion","SizeOfOptionalHeader","ResourcesMinEntropy","ResourcesMaxEntropy","SectionsMeanEntropy","DllCharacteristics","SectionsMaxEntropy","legitimate"]]

# Suppression des features
malware_prepared = malware[["Subsystem","MajorSubsystemVersion","SizeOfOptionalHeader","ResourcesMinEntropy","ResourcesMaxEntropy","SectionsMeanEntropy","DllCharacteristics","SectionsMaxEntropy","legitimate"]]

# Extraction des étiquettes
legitimate = malware_prepared["legitimate"].copy()
malware_prepared = malware_prepared.drop("legitimate", axis=1)

# Scaling des features
for col in malware_prepared.columns:
    malware_prepared[col] = (malware_prepared[col] - malware_prepared[col].median()) / (malware_prepared[col].max() - malware_prepared[col].min())

# Entrainement de l'algorithme
malware_prepared["legitimate"] = legitimate

train, test = train_test_split(malware_prepared, test_size=0.2, random_state=42)

X_train = train_data = train.drop("legitimate", axis=1)
y_train = train_label = train["legitimate"].copy()


## SVM algorithm
poly_kernel_svm_clf = SVC(kernel="rbf", degree=1, coef0=0.1, C=100)


# Entraînement
print("Démarage de l'entrainement")
poly_kernel_svm_clf.fit(X_train, y_train)
print("fin de l'entrainement")

# Création de la fenêtre 
window=Tk()
btn2=Button(window, text="select", command = lambda:open_file())
btn2.place(x=195, y=50)
lbl=Label(window, text="Select your file", fg='red', font=("Helvetica", 16))
lbl.place(x=155, y=10)
window.title('Malware analyser')
window.geometry("450x150+10+10")
window.resizable(0,0)
window.mainloop()
